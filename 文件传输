import depthai as dai
import cv2
import numpy as np

"""
Blob 模型诊断工具
用于检查模型输出格式和配置是否匹配
"""

MODEL_PATH = 'models/knottedblob/knottedtraffic1016.blob'

print("=" * 60)
print("Blob 模型诊断工具")
print("=" * 60)

# 创建简单的测试 pipeline
pipeline = dai.Pipeline()

# RGB 相机
cam = pipeline.create(dai.node.ColorCamera)
cam.setPreviewSize(416, 416)
cam.setInterleaved(False)

# 神经网络节点（使用基础 NeuralNetwork 而非 YoloSpatialDetectionNetwork）
nn = pipeline.create(dai.node.NeuralNetwork)
nn.setBlobPath(MODEL_PATH)

# 输出
xout_nn = pipeline.create(dai.node.XLinkOut)
xout_nn.setStreamName("nn")

# 链接
cam.preview.link(nn.input)
nn.out.link(xout_nn.input)

print("\n[1/3] 连接设备...")
try:
    device = dai.Device(pipeline)
    print("✓ 设备连接成功")
    print(f"  DepthAI 版本: {dai.__version__}")
except Exception as e:
    print(f"✗ 连接失败: {e}")
    exit(1)

print("\n[2/3] 分析模型输出...")

q_nn = device.getOutputQueue("nn", maxSize=1, blocking=True)

# 获取一帧输出
nn_data = q_nn.get()

print("\n=== 模型输出信息 ===")

# 方法1：尝试获取所有层
try:
    layers = nn_data.getAllLayerNames()
    print(f"\n输出层数量: {len(layers)}")
    for i, layer_name in enumerate(layers):
        print(f"\n层 {i}: {layer_name}")
        try:
            layer_data = nn_data.getLayerFp16(layer_name)
            print(f"  数据类型: FP16")
            print(f"  数据形状: {layer_data.shape if hasattr(layer_data, 'shape') else 'N/A'}")
            print(f"  数据大小: {len(layer_data)}")
            
            # 尝试推断形状
            if len(layer_data) == 24 * 52 * 52:
                print(f"  → 推断形状: [1, 24, 52, 52] 或 [1, 3, 52, 52, 8]")
            elif len(layer_data) == 24 * 26 * 26:
                print(f"  → 推断形状: [1, 24, 26, 26] 或 [1, 3, 26, 26, 8]")
            elif len(layer_data) == 24 * 13 * 13:
                print(f"  → 推断形状: [1, 24, 13, 13] 或 [1, 3, 13, 13, 8]")
            
            # 检查数值范围
            layer_array = np.array(layer_data)
            print(f"  数值范围: [{layer_array.min():.3f}, {layer_array.max():.3f}]")
            print(f"  均值: {layer_array.mean():.3f}")
            
        except Exception as e:
            print(f"  ✗ 无法读取: {e}")
            
except Exception as e:
    print(f"✗ 获取层信息失败: {e}")

# 方法2：尝试使用 YoloSpatialDetectionNetwork 的解析
print("\n\n[3/3] 测试 YOLO 解析...")

pipeline2 = dai.Pipeline()
cam2 = pipeline2.create(dai.node.ColorCamera)
cam2.setPreviewSize(416, 416)
cam2.setInterleaved(False)

yolo_nn = pipeline2.create(dai.node.MobileNetSpatialDetectionNetwork)
yolo_nn.setBlobPath(MODEL_PATH)
yolo_nn.setConfidenceThreshold(0.3)

xout2 = pipeline2.create(dai.node.XLinkOut)
xout2.setStreamName("det")

cam2.preview.link(yolo_nn.input)
yolo_nn.out.link(xout2.input)

try:
    device2 = dai.Device(pipeline2)
    q_det = device2.getOutputQueue("det", 1, True)
    
    det_data = q_det.get()
    detections = det_data.detections
    
    print(f"✓ YOLO 解析成功")
    print(f"  检测数量: {len(detections)}")
    
    if len(detections) > 10:
        print(f"  ⚠️  警告：检测框过多({len(detections)})，可能 NMS 失效")
    
    # 显示前5个检测
    for i, det in enumerate(detections[:5]):
        print(f"\n  检测 {i+1}:")
        print(f"    标签: {det.label}")
        print(f"    置信度: {det.confidence:.3f}")
        print(f"    bbox: [{det.xmin:.3f}, {det.ymin:.3f}, {det.xmax:.3f}, {det.ymax:.3f}]")
    
    device2.close()
    
except Exception as e:
    print(f"✗ YOLO 解析失败: {e}")

device.close()

print("\n" + "=" * 60)
print("诊断完成")
print("=" * 60)

print("\n### 建议 ###")
print("1. 如果输出层是 [1, 24, H, W] 格式:")
print("   → 这是通道优先格式，DepthAI 可能无法正确解析")
print("   → 建议重新导出 ONNX，使用 [1, 3, H, W, 8] 格式")
print()
print("2. 如果检测框过多 (>10):")
print("   → NMS 未正确应用")
print("   → 尝试不设置 setAnchors 和 setAnchorMasks")
print("   → 或调整 IoU 阈值到 0.7+")
print()
print("3. 如果黄灯误检:")
print("   → 训练数据可能不平衡")
print("   → 在代码中添加类别特定的置信度阈值")
print("   → 考虑重新训练，增加黄灯的负样本")
