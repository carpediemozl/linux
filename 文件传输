import cv2
import depthai as dai
import numpy as np
import time

"""
终极诊断和修复方案
针对 [1, 24, 52, 52] 格式的完整解析
"""

MODEL_PATH = 'models/knottedblob/knottedtraffic1016.blob'
LABEL_MAP = ['red', 'yellow', 'green']
NN_INPUT_SIZE = 416

# === YOLO 参数配置 ===
NUM_CLASSES = 3
ANCHORS = np.array([
    [[10, 13], [16, 30], [33, 23]],      # 52x52 层
    [[30, 61], [62, 45], [59, 119]],     # 26x26 层
    [[116, 90], [156, 198], [373, 326]]  # 13x13 层
], dtype=np.float32)

STRIDES = [8, 16, 32]

# === 可配置参数（用于调试）===
DEBUG_MODE = True  # 显示详细调试信息
CONF_THRESHOLD = 0.4  # 全局置信度阈值
IOU_THRESHOLD = 0.5   # NMS IoU 阈值

# 类别特定阈值（针对黄灯误检）
CLASS_THRESHOLDS = {
    0: 0.4,  # red
    1: 0.6,  # yellow - 提高黄灯阈值
    2: 0.4   # green
}


def sigmoid(x):
    """Sigmoid 激活"""
    return 1 / (1 + np.exp(-np.clip(x, -20, 20)))


def decode_layer(output, layer_idx, conf_thresh=0.4):
    """
    解码单个 YOLO 输出层
    
    Args:
        output: [24, H, W] numpy array
        layer_idx: 层索引 (0, 1, 2)
        conf_thresh: 置信度阈值
    
    Returns:
        detections: list of dict
    """
    detections = []
    
    # 获取尺寸
    _, h, w = output.shape
    stride = STRIDES[layer_idx]
    anchors = ANCHORS[layer_idx]
    
    # 重塑: [24, H, W] -> [3, 8, H, W]
    output = output.reshape(3, 8, h, w)
    
    # 遍历每个网格和锚框
    for anchor_idx in range(3):
        for i in range(h):
            for j in range(w):
                # 获取该锚框的预测 [8]
                pred = output[anchor_idx, :, i, j]
                
                # === 解析预测值 ===
                tx, ty, tw, th = pred[0:4]
                objectness = pred[4]
                class_scores = pred[5:8]
                
                # 应用 sigmoid
                objectness = sigmoid(objectness)
                
                # 快速过滤
                if objectness < conf_thresh:
                    continue
                
                # 类别预测
                class_scores = sigmoid(class_scores)
                class_id = np.argmax(class_scores)
                class_conf = class_scores[class_id]
                
                # 最终置信度
                final_conf = objectness * class_conf
                
                # 类别特定阈值
                if final_conf < CLASS_THRESHOLDS.get(class_id, conf_thresh):
                    continue
                
                # === 解码边界框 ===
                # 中心点
                cx = (sigmoid(tx) + j) * stride
                cy = (sigmoid(ty) + i) * stride
                
                # 宽高
                anchor = anchors[anchor_idx]
                bw = anchor[0] * np.exp(np.clip(tw, -10, 10))
                bh = anchor[1] * np.exp(np.clip(th, -10, 10))
                
                # 转换为 xyxy 格式（归一化）
                x1 = (cx - bw/2) / NN_INPUT_SIZE
                y1 = (cy - bh/2) / NN_INPUT_SIZE
                x2 = (cx + bw/2) / NN_INPUT_SIZE
                y2 = (cy + bh/2) / NN_INPUT_SIZE
                
                # 裁剪到 [0, 1]
                x1 = np.clip(x1, 0, 1)
                y1 = np.clip(y1, 0, 1)
                x2 = np.clip(x2, 0, 1)
                y2 = np.clip(y2, 0, 1)
                
                # 检查有效性
                if x2 <= x1 or y2 <= y1:
                    continue
                
                detections.append({
                    'label': int(class_id),
                    'confidence': float(final_conf),
                    'objectness': float(objectness),
                    'class_conf': float(class_conf),
                    'bbox': [float(x1), float(y1), float(x2), float(y2)],
                    'layer': layer_idx,
                    'grid': (i, j),
                    'anchor': anchor_idx
                })
    
    return detections


def non_max_suppression(detections, iou_threshold=0.5):
    """NMS 实现"""
    if len(detections) == 0:
        return []
    
    # 按置信度排序
    detections = sorted(detections, key=lambda x: x['confidence'], reverse=True)
    keep = []
    
    while detections:
        best = detections.pop(0)
        keep.append(best)
        
        # 过滤重叠框（同类别）
        new_detections = []
        for det in detections:
            # 不同类别不做 NMS
            if det['label'] != best['label']:
                new_detections.append(det)
            elif iou(best['bbox'], det['bbox']) < iou_threshold:
                new_detections.append(det)
        
        detections = new_detections
    
    return keep


def iou(box1, box2):
    """计算 IoU"""
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])
    
    inter = max(0, x2 - x1) * max(0, y2 - y1)
    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])
    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])
    
    return inter / (area1 + area2 - inter + 1e-6)


def process_outputs(outputs, conf_thresh=0.4, iou_thresh=0.5):
    """处理所有输出层"""
    all_detections = []
    
    for layer_idx, output in enumerate(outputs):
        layer_dets = decode_layer(output, layer_idx, conf_thresh)
        all_detections.extend(layer_dets)
    
    # NMS
    final_detections = non_max_suppression(all_detections, iou_thresh)
    
    return final_detections


# ===== Pipeline 构建 =====
print("=" * 60)
print("交通灯检测 - 终极修复版")
print("=" * 60)
print(f"模型: {MODEL_PATH}")
print(f"置信度阈值: {CONF_THRESHOLD}")
print(f"IoU 阈值: {IOU_THRESHOLD}")
print(f"类别阈值: {CLASS_THRESHOLDS}")
print("=" * 60)

pipeline = dai.Pipeline()

cam_rgb = pipeline.create(dai.node.ColorCamera)
nn = pipeline.create(dai.node.NeuralNetwork)

xout_rgb = pipeline.create(dai.node.XLinkOut)
xout_rgb.setStreamName("rgb")
xout_nn = pipeline.create(dai.node.XLinkOut)
xout_nn.setStreamName("nn")

# 配置
cam_rgb.setPreviewSize(NN_INPUT_SIZE, NN_INPUT_SIZE)
cam_rgb.setResolution(dai.ColorCameraProperties.SensorResolution.THE_1080_P)
cam_rgb.setInterleaved(False)
cam_rgb.setColorOrder(dai.ColorCameraProperties.ColorOrder.BGR)

nn.setBlobPath(MODEL_PATH)
nn.setNumInferenceThreads(2)

cam_rgb.preview.link(nn.input)
cam_rgb.preview.link(xout_rgb.input)
nn.out.link(xout_nn.input)

print("\n正在连接设备...")

# ===== 主循环 =====
try:
    with dai.Device(pipeline) as device:
        print("✓ 设备连接成功")
        print(f"  DepthAI 版本: {dai.__version__}\n")
        
        q_rgb = device.getOutputQueue("rgb", maxSize=4, blocking=False)
        q_nn = device.getOutputQueue("nn", maxSize=4, blocking=False)
        
        startTime = time.monotonic()
        counter = 0
        fps = 0
        frame_count = 0
        
        # 统计
        detection_history = []

        while True:
            in_rgb = q_rgb.get()
            in_nn = q_nn.get()

            frame = in_rgb.getCvFrame()
            frame_count += 1
            
            # === 获取并解析输出 ===
            try:
                output0 = np.array(in_nn.getLayerFp16('output0')).reshape(24, 52, 52)
                output1 = np.array(in_nn.getLayerFp16('output1')).reshape(24, 26, 26)
                output2 = np.array(in_nn.getLayerFp16('output2')).reshape(24, 13, 13)
                
                outputs = [output0, output1, output2]
                
                # 处理检测
                detections = process_outputs(
                    outputs, 
                    conf_thresh=CONF_THRESHOLD,
                    iou_thresh=IOU_THRESHOLD
                )
                
                detection_history.append(len(detections))
                
            except Exception as e:
                print(f"解析错误: {e}")
                detections = []
            
            # === FPS 计算 ===
            counter += 1
            currentTime = time.monotonic()
            if (currentTime - startTime) > 1:
                fps = counter / (currentTime - startTime)
                counter = 0
                startTime = currentTime
            
            # === 调试输出 ===
            if DEBUG_MODE and frame_count % 30 == 0:
                print(f"\n[帧 {frame_count}] 检测数: {len(detections)}")
                for i, det in enumerate(detections[:5]):  # 只显示前5个
                    label = LABEL_MAP[det['label']]
                    print(f"  {i+1}. {label}: conf={det['confidence']:.3f} "
                          f"(obj={det['objectness']:.3f}, cls={det['class_conf']:.3f}) "
                          f"layer={det['layer']}")
            
            # === 绘制 ===
            for det in detections:
                x1 = int(det['bbox'][0] * frame.shape[1])
                y1 = int(det['bbox'][1] * frame.shape[0])
                x2 = int(det['bbox'][2] * frame.shape[1])
                y2 = int(det['bbox'][3] * frame.shape[0])
                
                label = LABEL_MAP[det['label']]
                
                # 颜色映射
                color_map = {
                    'red': (0, 0, 255),
                    'yellow': (0, 255, 255),
                    'green': (0, 255, 0)
                }
                color = color_map.get(label, (255, 255, 255))
                
                # 绘制
                cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                
                # 标签
                text = f"{label} {det['confidence']:.2f}"
                cv2.putText(frame, text, (x1, y1-10), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                
                # 调试信息
                if DEBUG_MODE:
                    debug_text = f"L{det['layer']}"
                    cv2.putText(frame, debug_text, (x1, y2+15), 
                               cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)
            
            # === 显示信息 ===
            cv2.putText(frame, f"FPS: {fps:.1f}", 
                       (5, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            cv2.putText(frame, f"Detections: {len(detections)}", 
                       (5, 45), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            
            # 平均检测数
            if len(detection_history) > 30:
                avg_dets = sum(detection_history[-30:]) / 30
                cv2.putText(frame, f"Avg: {avg_dets:.1f}", 
                           (5, 70), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
            
            cv2.imshow("Traffic Light Detection", frame)

            key = cv2.waitKey(1)
            if key == ord('q'):
                break
            elif key == ord('d'):
                DEBUG_MODE = not DEBUG_MODE
                print(f"\n调试模式: {'开' if DEBUG_MODE else '关'}")
            elif key == ord('+'):
                CONF_THRESHOLD = min(0.9, CONF_THRESHOLD + 0.05)
                print(f"\n置信度阈值: {CONF_THRESHOLD:.2f}")
            elif key == ord('-'):
                CONF_THRESHOLD = max(0.1, CONF_THRESHOLD - 0.05)
                print(f"\n置信度阈值: {CONF_THRESHOLD:.2f}")

except Exception as e:
    print(f"\n错误: {e}")
    import traceback
    traceback.print_exc()

finally:
    cv2.destroyAllWindows()
    print("\n脚本结束。")
    
    # 显示统计
    if detection_history:
        print(f"\n=== 检测统计 ===")
        print(f"总帧数: {frame_count}")
        print(f"平均检测数: {sum(detection_history)/len(detection_history):.2f}")
        print(f"最大检测数: {max(detection_history)}")
        print(f"最小检测数: {min(detection_history)}")
